---
title: 01.MySql事务
date: 2021-02-09 11:43:24
permalink: /pages/172127/
categories:
  - 面试题
  - MySql
tags:
  - 

---

# 01.mysql事务

## 1.1 InnoDB事务原理

- 事务（Transaction）是数据库区别于文件系统的重要特性之一，事务会把数据库从一种一致性状态转换为另一种一致性状态。
- 在数据库提交时，可以确保要么所有修改都已保存，要么所有修改都不保存。


## 1.2 事务四大特性

- 原子性：整个事物的所有操作要么全部提交成功，要么全部失败回滚(`要么全部执行，要么全部回滚`)。
- 一致性：几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致（`几个并行事务执行结果相同`）。
- 隔离性：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。
- 持久性:  一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

> `原子性和一致性区别`

- 原子性并不能保证一致性，在多事务并行情况下，即使保证每个事物原子性，仍然可能数据不一致
- 比如：假如同时开启两个事物A和B都要给tom账号转100元，可能增加两次，但是有一次被另一个事物覆盖

## 1.3 InnoDB与MyISAM

- **`MyISAM不支持事物回滚，InnoDB是支持事物`**
- **MyISAM**和MEMORY存储引擎采用的是**表级锁**（table-level locking）。
- **InnoDB**存储引擎既支持**行级锁**（row-level locking），也支持**表级锁**，但默认情况下是采用行级锁。
     - MyISAM更适合查询多的情况
     - InnoDB更适合写入多的

## 1.4 事务隔离级别

### 1.4.1 未提交读: 脏读

- `读取到其他事务修改但未提交数据`

- 1）事务2查询到的数据是事务1中修改但未提交的数据，但因为事务1回滚了数据
- 2）所以事务2查询的数据是不正确的，因此出现了脏读的问题。

### 1.4.2 提交读: 不可重复读

- `事务1读取到事务2修改前和修改后的数据，两次读取数据不一样`

- **注：**一个事务从开始到提交之前对数据所做的改变对其它事务是不可见的，这样就解决在READ-UNCOMMITTED级别下的脏读问题。
- 1）事务2执行update语句但未提交前，事务1的前两个select操作返回结果是相同的。
- 2）但事务2执行commit操作后，事务1的第三个select操作就读取到事务2对数据的改变。
- 3）导致与前两次select操作返回不同的数据，因此出现了不可重复读的问题。

### 1.4.3 可重复读: 幻读(mysql默认)

- `事务1在自己版本号中，查询到另一个事务插入新的数据行，这就会导致该事物中凭空多出数据行`

- `这是MySQL的默认事务隔离级别`

- 1）事务每开启一个实例，都会分配一个版本号给它，如果读取的数据行正在被其它事务执行DELETE或UPDATE操作（即该行上有排他锁）

- 2）这时该事物的读取操作不会等待行上的锁释放，而是根据版本号去读取行的快照数据（记录在undo log中）

- 3）这样，事务中的查询操作返回的都是同一版本下的数据，解决了不可重复读问题。

- 4）虽然该隔离级别下解决了不可重复读问题，但理论上会导致另一个问题：幻读（Phantom Read）。

- 5）一个事务在执行过程中，另一个事物对已有数据行的更改，MVCC机制可保障该事物读取到的原有数据行的内容相同

- 6）但并不能阻止另一个事务插入新的数据行，这就会导致该事物中凭空多出数据行，像出现了幻读一样，这便是幻读问题。

### 1.4.4 可串行读

- 1）这是事务的最高隔离级别，通过强制事务排序，使之不可能相互冲突，就是在每个读的数据行加上共享锁来实现。

- 2）在该隔离级别下，可以解决前面出现的脏读、不可重复读和幻读问题，但也会导致大量的超时和锁竞争现象，一般不推荐使用。



